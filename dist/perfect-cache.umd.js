(function(f,p){typeof exports=="object"&&typeof module!="undefined"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(f=typeof globalThis!="undefined"?globalThis:f||self,p(f.PerfectCache={}))})(this,function(f){"use strict";var I=Object.defineProperty;var $=(f,p,b)=>p in f?I(f,p,{enumerable:!0,configurable:!0,writable:!0,value:b}):f[p]=b;var l=(f,p,b)=>($(f,typeof p!="symbol"?p+"":p,b),b);var p={driver:"memory"};function b(i){return{all:i=i||new Map,on:function(s,t){var r=i.get(s);r?r.push(t):i.set(s,[t])},off:function(s,t){var r=i.get(s);r&&(t?r.splice(r.indexOf(t)>>>0,1):i.set(s,[]))},emit:function(s,t){var r=i.get(s);r&&r.slice().map(function(e){e(t)}),(r=i.get("*"))&&r.slice().map(function(e){e(s,t)})}}}class R{constructor(){l(this,"mitt",new b)}$on(){return this.mitt.on.apply(this,arguments)}$off(){return this.mitt.off.apply(this,arguments)}$emit(){return this.mitt.emit.apply(this,arguments)}}class E extends R{constructor(t={}){super();l(this,"opts");l(this,"isAsync",!1);l(this,"isReady",!1);this.opts=t,this.isReady=!1}existsKey(){throw new Error("please implement the existsKey method for this driver.")}get(){throw new Error("please implement the get method for this driver.")}set(){throw new Error("please implement the set method for this driver.")}}const y={OK:Symbol("OK"),KEY_NOT_EXISTS:Symbol("KEY_NOT_EXISTS"),KEY_EXPIRED:Symbol("KEY_EXPIRED"),JSON_PARSE_ERROR:Symbol("JSON_PARSE_ERROR"),NX_SET_NOT_PERFORMED:Symbol("NX_SET_NOT_PERFORMED"),XX_SET_NOT_PERFORMED:Symbol("XX_SET_NOT_PERFORMED")};class w extends E{constructor(s){super(s),this.isAsync=!1,setTimeout(()=>{this.isReady=!0,this.$emit("ready")},0)}keyValueGet(){throw new Error("please implement the keyValueGet method for this driver.")}keyValueSet(){throw new Error("please implement the keyValueSet method for this driver.")}existsKey(){throw new Error("please implement the existsKey method for this driver.")}get(s){const t=this.keyValueGet(s);if(t)try{const r=JSON.parse(t);if(r.expiredAt){if(r.expiredAt>Date.now())return r.value;this.$emit("cacheExpired",s);return}else return r.value}catch(r){window.console.debug("get key json parse error",r);return}else return}set(s,t,r={}){const{expiredTime:e,expiredTimeAt:n,setOnlyNotExist:o=!1,setOnlyExist:a=!1}=r;let c,u;if(e&&typeof e=="number"&&e>0&&(c=Date.now()+e),n&&typeof n=="number"&&n>0&&(c=n),c&&(u=Math.max(c-Date.now(),0)),o||a){const h=this.existsKey(s);return o&&h?y.NX_SET_NOT_PERFORMED:a&&!h?y.XX_SET_NOT_PERFORMED:(this.keyValueSet(s,JSON.stringify({value:t,expiredAt:c,maxAge:u})),y.OK)}else return this.keyValueSet(s,JSON.stringify({value:t,expiredAt:c,maxAge:u})),y.OK}}class D extends w{keyValueGet(s){return localStorage.getItem(s)}keyValueSet(s,t){localStorage.setItem(s,t)}existsKey(s){return!!localStorage.getItem(s)}}l(D,"driver","localStorage");class N extends w{constructor(){super(...arguments);l(this,"data",new Map)}keyValueGet(t){return this.data.get(t)}keyValueSet(t,r){this.data.set(t,r)}existsKey(t){return!!this.data.has(t)}}l(N,"driver","memory");class k extends w{keyValueGet(s){return sessionStorage.getItem(s)}keyValueSet(s,t){sessionStorage.setItem(s,t)}existsKey(s){return!!sessionStorage.getItem(s)}}l(k,"driver","sessionStorage");/*! js-cookie v3.0.1 | MIT */function x(i){for(var s=1;s<arguments.length;s++){var t=arguments[s];for(var r in t)i[r]=t[r]}return i}var P={read:function(i){return i[0]==='"'&&(i=i.slice(1,-1)),i.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(i){return encodeURIComponent(i).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}};function v(i,s){function t(e,n,o){if(typeof document!="undefined"){o=x({},s,o),typeof o.expires=="number"&&(o.expires=new Date(Date.now()+o.expires*864e5)),o.expires&&(o.expires=o.expires.toUTCString()),e=encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var a="";for(var c in o)!o[c]||(a+="; "+c,o[c]!==!0&&(a+="="+o[c].split(";")[0]));return document.cookie=e+"="+i.write(n,e)+a}}function r(e){if(!(typeof document=="undefined"||arguments.length&&!e)){for(var n=document.cookie?document.cookie.split("; "):[],o={},a=0;a<n.length;a++){var c=n[a].split("="),u=c.slice(1).join("=");try{var h=decodeURIComponent(c[0]);if(o[h]=i.read(u,h),e===h)break}catch{}}return e?o[e]:o}}return Object.create({set:t,get:r,remove:function(e,n){t(e,"",x({},n,{expires:-1}))},withAttributes:function(e){return v(this.converter,x({},this.attributes,e))},withConverter:function(e){return v(x({},this.converter,e),this.attributes)}},{attributes:{value:Object.freeze(s)},converter:{value:Object.freeze(i)}})}var O=v(P,{path:"/"});class j extends w{keyValueGet(s){return O.get(s)}keyValueSet(s,t){O.set(s,t)}existsKey(s){return!!O.get(s)}}l(j,"driver","cookie");class C extends E{constructor(s){super(s),this.isAsync=!0}keyValueGet(){return Promise.reject(new Error("please implement the keyValueGet method for this driver."))}keyValueSet(){return Promise.reject(new Error("please implement the keyValueSet method for this driver."))}existsKey(){return Promise.reject(new Error("please implement the existsKey method for this driver."))}get(s){return new Promise((t,r)=>{this.keyValueGet(s).then(e=>{if(e)try{const n=JSON.parse(e);n.expiredAt?n.expiredAt>Date.now()?t(n.value):(this.$emit("cacheExpired",s),t()):t(n.value)}catch(n){window.console.debug("get key json parse error",n),t()}else t()}).catch(e=>{r(e)})})}set(s,t,r={}){const{expiredTime:e,expiredTimeAt:n,setOnlyNotExist:o=!1,setOnlyExist:a=!1}=r;let c,u;return e&&typeof e=="number"&&e>0&&(c=Date.now()+e),n&&typeof n=="number"&&n>0&&(c=n),c&&(u=Math.max(c-Date.now(),0)),new Promise((h,m)=>{o||a?this.existsKey(s).then(d=>{if(o&&d)return h(y.NX_SET_NOT_PERFORMED);if(a&&!d)return h(y.XX_SET_NOT_PERFORMED);this.keyValueSet(s,JSON.stringify({value:t,expiredAt:c,maxAge:u})).then(()=>h(y.OK)).catch(g=>{m(g)})}).catch(d=>{m(d)}):this.keyValueSet(s,JSON.stringify({value:t,expiredAt:c,maxAge:u})).then(()=>h(y.OK)).catch(d=>{m(d)})})}}class V extends C{constructor(t){var r,e,n;super(t);l(this,"dbName","perfect-cache");l(this,"objectStoreName","perfect-cache");l(this,"dbVersion",1);l(this,"dbConnection");this.isReady=!1,(r=this.opts)!=null&&r.dbName&&(this.dbName=this.opts.dbName),(e=this.opts)!=null&&e.objectStoreName&&(this.objectStoreName=this.opts.objectStoreName),(n=this.opts)!=null&&n.dbVersion&&(this.dbVersion=this.opts.dbVersion),this.connectDB().then(()=>{this.initObjectStore()})}connectDB(){return new Promise((t,r)=>{const e=window.indexedDB.open(this.dbName,this.dbVersion);e.onerror=()=>{window.console.error(`Database ${this.dbName} init occurs error`,e.result),r(e.result)},e.onsuccess=()=>{this.dbConnection=e.result,window.console.debug(`Database ${this.dbName} initialised.`),t(this.dbConnection)},e.onupgradeneeded=n=>{this.dbConnection=n.target.result,window.console.debug("Database version upgraded success."),t(this.dbConnection)}})}initObjectStore(){return new Promise((t,r)=>{if(this.dbConnection)this.dbConnection.objectStoreNames.contains(this.objectStoreName)||this.dbConnection.createObjectStore(this.objectStoreName,{keyPath:"key"}),this.isReady=!0,this.$emit("ready"),t();else{const e=new Error(`Database ${this.dbName} connection is not initialised.`);window.console.error(e),r(e)}})}keyValueGet(t){return new Promise((r,e)=>{if(this.dbConnection){const n=this.dbConnection.transaction([this.objectStoreName],"readonly").objectStore(this.objectStoreName).get(t);n.onerror=()=>{window.console.error("Database keyValueGet occurs error",n.result),e(n.result)},n.onsuccess=()=>{var o;r((o=n.result)==null?void 0:o.value)}}else{const n=new Error(`Database ${this.dbName} connection is not initialised.`);window.console.error(n),e(n)}})}keyValueSet(t,r){return new Promise((e,n)=>{if(this.dbConnection){const o=this.dbConnection.transaction([this.objectStoreName],"readwrite").objectStore(this.objectStoreName).put({key:t,value:r});o.onerror=()=>{window.console.error("Database keyValueSet occurs error",o.result),n(o.result)},o.onsuccess=()=>{var a;e((a=o.result)==null?void 0:a.value)}}else{const o=new Error(`Database ${this.dbName} connection is not initialised.`);window.console.error(o),n(o)}})}existsKey(t){return new Promise((r,e)=>{if(this.dbConnection){const n=this.dbConnection.transaction([this.objectStoreName],"readonly").objectStore(this.objectStoreName).count(t);n.onerror=()=>{window.console.error("Database existsKey occurs error",n.result),e(n.result)},n.onsuccess=()=>{r(!!n.result)}}else{const n=new Error(`Database ${this.dbName} connection is not initialised.`);window.console.error(n),e(n)}})}}l(V,"driver","indexedDB");const S={};for(const i of[N,D,k,j,V])S[i.driver]=i;const _={},T=i=>{if(Object.getPrototypeOf(i)===E)if(i.driver&&typeof i.driver=="string")_[i.driver]=i;else throw new Error("please input the driver name.")},F=()=>{var s;let i=["memory"];return(window==null?void 0:window.localStorage)&&S.localStorage&&i.push("localStorage"),(window==null?void 0:window.sessionStorage)&&S.sessionStorage&&i.push("sessionStorage"),((s=window==null?void 0:window.document)==null?void 0:s.cookie)&&S.cookie&&i.push("cookie"),(window==null?void 0:window.indexedDB)&&S.indexedDB&&i.push("indexedDB"),i=i.concat(Object.keys(_)),i},K=i=>S[i]||_[i];class A extends R{constructor(t,r){super();l(this,"opts");l(this,"__init",!1);l(this,"driver");l(this,"store");l(this,"keyFallbacks",[]);l(this,"keyRegexFallbacks",[]);const e=F();if(!t&&!r)r={...p};else if(t)if(e.includes(t))Object.prototype.toString.call(r)==="[object Object]"?r={...p,driver:t,...r}:r={...p,driver:t};else if(Object.prototype.toString.call(t)==="[object Object]"&&e.includes(t.driver))r={...p,...t};else throw new Error("please input the correct driver param as the first param or in the opts params.");else throw new Error("please input the driver as first param.");if(r&&r.driver)this.opts=r,this.initDriver();else throw new Error("please input the driver as first param.")}initDriver(){const t=F();if(this.opts&&this.opts.driver&&t.includes(this.opts.driver)){this.__init=!1;const r=K(this.opts.driver);this.store=new r(this.opts),this.store.$on("ready",()=>{this.__init=!0,this.driver=this.opts.driver,this.$emit("ready")}),this.store.$on("cacheExpired",e=>{this.$emit("cacheExpired",e)})}}setDriver(t){this.opts.driver=t,this.initDriver()}existsKey(){return this.store.existsKey.apply(this.store,arguments)}get(t,r={}){const{defaultVal:e,withFallback:n=!0,refreshCache:o=!0}=r;if(this.isAsync)return new Promise(async(a,c)=>{const u=await this.store.get(t),h=u==null||u==="";if(h&&n){const m=this.__getFallbackByKey(t);if(m){const d=await m.fallback(t),g=d==null||d==="";o&&await this.store.set(t,d,{expiredTime:m.expiredTime}),a(g&&e!==void 0?e:d)}else a(e===void 0?u:e)}else a(h&&e!==void 0?e:u)});{const a=this.store.get(t),c=a==null||a==="";if(c&&n){const u=this.__getFallbackByKey(t);if(u){const h=u.fallback(t);let m;if(h instanceof Promise)return h().then(d=>{const g=d==null||d==="";return o&&this.store.set(t,d,{expiredTime:u.expiredTime}),g&&e!==void 0?e:d});{m=h;const d=m==null||m==="";return o&&this.store.set(t,m,{expiredTime:u.expiredTime}),d&&e!==void 0?e:m}}else return e===void 0?a:e}else return c&&e!==void 0?e:a}}set(){return this.store.set.apply(this.store,arguments)}fallbackKey(t,r,e){if(!e&&r instanceof Function&&(e=r,r=null),typeof t=="string"){if(e instanceof Function&&(!r||typeof r=="number"))return this.keyFallbacks.push({key:t,expiredTime:r,fallback:e});throw new Error("please input the expiredTime as type [number] and fallback as type [Function]")}if(t instanceof RegExp){if(e instanceof Function&&(!r||typeof r=="number"))return this.keyRegexFallbacks.push({regex:t,expiredTime:r,fallback:e});throw new Error("please input the expiredTime as type [number] and fallback as type [Function]")}}__getFallbackByKey(t){let r=this.keyFallbacks.find(e=>e.key===t&&e.fallback instanceof Function);return r||(r=this.keyRegexFallbacks.find(e=>e.regex.test(t)&&e.fallback instanceof Function),r)}}f.AsyncStore=C,f.BaseStore=E,f.PerfectCache=A,f.StoreResult=y,f.SyncStore=w,f.registerStore=T,Object.defineProperties(f,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
